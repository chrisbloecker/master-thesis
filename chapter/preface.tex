$\;$
\clearpage
\renewcommand*{\dictumwidth}{.6\textwidth}
\dictum[Donald E. Knuth]{If you find that you're spending almost all your time on theory, start turning some attention to practical things; it will improve your theories. If you find that you're spending almost all your time on practice, start turning some attention to theoretical things; it will improve your practice.}

\addcontentsline{toc}{section}{Preface}
\section*{Preface}
In the very beginning it was my idea to build a distributed system that offers optimisation as a service, motivated by the omnipresence of computationally hard problems in theory and practice. I started investigating in the idea in the context of a software project and by building a prototype of the system I had in mind.

My first attempt started off in \textsf{elixir}, a functional, dynamically typed programming language that could be described as a \textsf{Ruby}-fied version of \textsf{Erlang} and equally well suited for distributed programming as \textsf{Erlang}. But I found myself missing \textsf{Haskell} and its type system very soon after I started to design my data model and tried to express it in \textsf{elixir}. The main problem was the question how to constrain the user to only submit valid process structures that obey the rules concerning static semantics of process composition. I took the decision to switch to \textsf{Haskell} and started over from scratch.

I finished the software project with a working prototype of an optimisation system implemented in \textsf{Haskell} and learned some lessons from it. There was more fundamental work to do than I had expected in the beginning. Of course there were tools for distributed programming, but I found they were mixing technical details about process management and communication with problem-specific code of algorithms. Furthermore, it was my idea to describe algorithms as a composition of processes and have them interpreted and executed in a distributed system. I decided to build the foundation that would allow to do so: a process calculus.

While designing the model for my process calculus and working on the implementation, I found myself running into the situation that Donald Knuth advises to avoid. In turns, I spent too much time only thinking about theory and only working on the implementation. As a result I ended up with a gap between model and implementation. I had to take a step back and take a look at the whole picture. In the end, this led to an elegant model (if I may say so) and an implementation closely resembling it.

Once the calculus was designed and the implementation done, I realised that distribution isn't the only thing the calculus can be used for. Parallelisation of algorithms on one computer is feasible as well and of interest for practical applications. It went fast to implement a second interpreter for processes, running on only one computer, not involving distribution. I was a bit surprised to see that the variant for parallelisation performs so much better than the distributed one that had been my goal from the beginning. Unfortunately, there was no time left to investigate in the reasons for this and to improve the performance of the distributed system.

\vfill

\noindent
Bargteheide, $2^\text{nd}$ of March 2015 \hfill Christopher Bl√∂cker