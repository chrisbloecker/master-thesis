\chapter{Related Work}
We will give an overview on related work that has been done in this field. First, we briefly introduce two process calculi, i.e. formalisms that allow to describe the behaviour of processes. After that we will have a look at an algebraic model that generalises the concepts that can be found in the introduced process calculi as well as others. In the end of this chapter, we will explore how the explained concepts are implemented in some current programming languages.

\section{Process calculi}
Process calculi are formalisms that can be used to describe processes and their behaviour in a concurrent system on a high level. The description is done in a mathematical way, comparable to algebraic structures, and independently from an implementation \cite{}. Usually process calculi operate on abstract processes and provide a set of operators and combinators which can be used to compose processes. By introducing this kind of formalism, process calculi make it possible to reason about processes and perform (equivalence) transformations on them, e.g. to obtain a more optimised\footnote{Optimised according to a defined criterion.} representation \cite{}.

\subsection{Calculus of Communicating Systems}
The Calculus of Communicating Systems, short \textsc{CCS}, is a process algebra introduced by Robin Milner in 1982 \cite{Milner:1982:CCS:539036}. \textsc{CCS} was one of the first process calculi in the history of computer science. It comprises a relatively small set of combinators which are used to describe process behaviour. We will give an overview over most of them and illustrate how to use them. Note that our introduction to \textsc{CCS} will not be complete and we only want to give a general idea.

In \textsc{CCS}, processes are composed of actions $\mathcal{A}$ and processes $\mathcal{P}$. In the following, let $a \in \mathcal{A}$ be actions and $P, Q, R \in \mathcal{P}$ be processes.

Processes in \textsc{CCS} are defined inductively. The empty process $\emptyset$ is the process that does nothing. Processes can be prefixed with an action to obtain a new process. $a.P$ describes a process that can execute action $a$ before it continues as process $P$. We can use the empty process $\emptyset$ together with the prefixing of actions \enquote{.} to build a process that consists of an arbitrary long but finite sequence of actions.

The composition of two processes can be made with the choice operator \enquote{+} and the parallel operator \enquote{|}. $P + Q$ describes a process that will proceed as either $P$ or $Q$. With $P | Q$ we can describe that processes $P$ and $Q$ exist and the same time and execute concurrently. Both for \enquote{+} and \enquote{|} the laws of associativity and commutativity hold, thus the following equations hold:

\begin{eqnarray*}
  P + \left( Q + R \right) & = & \left( P + Q \right) + R \\
  P \,|\, \left( Q \,|\, R \right) & = & \left( P \,|\, Q \right) \,|\, R \\
  P + Q & = & Q + P \\
  P \,|\, Q & = & Q \,|\, P \\
\end{eqnarray*}

\subsection{Communicating Sequential Processes}
Communicating Sequential Processes, or short \textsc{CSP}, was developed by Tony Hoare and published in 1985 \cite{Hoare:1985:CSP:3921}. It arose around the same time as \textsc{CCS} and belongs to the circle of the first process calculi. We will introduce a subset of \textsc{CSP} and show how to build processes using \textsc{CSP}, however we will not go too deep into detail and don't claim to provide a complete description.

In \textsc{CSP}, processes are composed of two types of primitives: sequential processes $\mathcal{P}$ and events $\mathcal{E}$. A process $P \in \mathcal{P}$ can observe an event $e \in \mathcal{E}$ and react to it. It cannot take influence on events or manipulate them as they are indivisible. In the following, let $P, Q \in \mathcal{P}$ be processes and $a,b \in \mathcal{E}$ be events.

The prefix combinator \enquote{$\to$} takes an event $a$ and a process $P$. $\left( a \to P \right)$ creates a new process that waits until it observes $a$ and then behaves like $P$. A process that repeatedly waits to observe $a$ and then behaves like $P$ can be described using recursion: $P = \left( a \to P \right)$.

With the choice operator \enquote{$|$} we can construct a process that allows two flows of control. The process $\left( a \to P \,|\, b \to Q \right)$ will wait until it either observes $a$ and then behave like $P$ or it will wait until it observes $b$ and then behave like $Q$. Note that the prefix operator binds stronger than the choice operator and that the choice operator is commutative.

The parallel operator \enquote{$||$} allows us to put processes together such that they run parallel. The process obtained by $\left( P \,||\, Q \right)$ will wait for an event that both $P$ and $Q$ can observe and then behave like $P$ and $Q$ concurrently\footnote{Note the difference between concurrency and nondeterminism.}. Let $P = \left( a \to P \,|\, b \to a \to P \right)$ and $Q = a \to Q$ then $\left( P \,||\, Q \right) = \left( a \to P \,||\, a \to Q \right)$, since $Q$ cannot observe $b$ and thus the second choice from $P$ has to be ommited.

In contrast to the parallel operator \enquote{$||$}, the interleaving operator \enquote{$|||$} can be used to put processes together to execute concurrently, independently from which events they are able to observe. The process $\left( P \,|||\, Q \right)$ behaves like $P$ and $Q$ at the same time. If an event occurs that either of the processes can observe, the according process will do so. If an event occurs that both processes, $P$ and $Q$, are able to observe, then the choice which of them observes it will be made nondeterministically.

We have now seen some basic combinators of \textsc{CSP} and how to use them in order to create composed processes based on primitive processes and events. We can construct processes that run in parallel and make their execution dependant on observable events. The formalism of \textsc{CSP} allows reasoning about processes and transformations on them. \textsc{CSP} comes with many more operators and combinators than the ones we have introdcued, but as already mentioned we do not intend to give a complete description.

%Unfortunately in \textsc{CSP} there exists communication between processes that is implicitly represented as events. Since we want to eliminate explicit communication between processes, \textsc{CSP} is unsuitable for our purposes.

\section{A general algebraic model}
\cite{Hoare:2012:LPU:2368298.2368301}

\section{Programming languages}

\subsection{Java}

\subsection{Erlang}

\subsection{Haskell}