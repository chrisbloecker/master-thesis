\chapter{Related Work}
We will give an overview on related work that has been done in this field. First, we briefly introduce two process calculi, i.e. formalisms that allow to describe the behaviour of processes. After that we will have a look at how these concepts are implemented in some current programming languages.

\section{Process calculi}
Process calculi are formalisms that can be used to describe processes and their behaviour in a concurrent system on a high level. The description is done in a mathematical way, comparable to algebraic structures, and independently from an implementation \cite{}. Usually process calculi operate on abstract processes and provide a set of operators and combinators which can be used to compose processes. By introducing this kind of formalism, process calculi make it possible to reason about processes and perform (equivalence) transformations on them, e.g. to obtain a more optimised\footnote{Optimised according to a defined criterion.} representation \cite{}.

\subsection{Communicating Sequential Processes}
Communicating Sequential Processes, or short \textsc{CSP}, was the first process algebra in the history of computer science. It has been developed by Tony Hoare and was published in 1985 \cite{Hoare:1985:CSP:3921}. We are going to introduce a subset of \textsc{CSP} and show how to build processes using \textsc{CSP}, however we will not go too deep into detail and don't claim to provide a complete description.

In \textsc{CSP}, processes are composed of two types of primitives: sequential processes $\mathcal{P}$ and events $\mathcal{E}$. A process $P \in \mathcal{P}$ can observe an event $e \in \mathcal{E}$ and react to it. It cannot take influence on events or manipulate them as they are indivisible. In the following, let $P, Q \in \mathcal{P}$ be processes and $a,b \in \mathcal{E}$ be events.

The prefix combinator \enquote{$\to$} takes an event $a$ and a process $P$. $\left( a \to P \right)$ creates a new process that waits until it observes $a$ and then behaves like $P$. A process that repeatedly waits to observe $a$ and then behaves like $P$ can be described using recursion: $P = \left( a \to P \right)$.

With the choice operator \enquote{$|$} we can construct a process that allows two flows of control. The process $\left( a \to P \,|\, b \to Q \right)$ will wait until it either observes $a$ and then behave like $P$ or it will wait until it observes $b$ and then behave like $Q$. Note that the prefix operator binds stronger than the choice operator and that the choice operator is commutative.

The parallel operator \enquote{$||$} allows us to put processes together such that they run parallel. The process obtained by $\left( P \,||\, Q \right)$ will wait for an event that both $P$ and $Q$ can observe and then behave like $P$ and $Q$ concurrently\footnote{Note the difference between concurrency and nondeterminism.}. Let $P = \left( a \to P \,|\, b \to a \to P \right)$ and $Q = a \to Q$ then $\left( P \,||\, Q \right) = \left( a \to P \,||\, a \to Q \right)$, since $Q$ cannot observe $b$ and thus the second choice from $P$ has to be ommited.

In contrast to the parallel operator \enquote{$||$}, the interleaving operator \enquote{$|||$} can be used to put processes together to execute concurrently, independently from which events they are able to observe. The process $\left( P \,|||\, Q \right)$ behaves like $P$ and $Q$ at the same time. If an event occurs that either of the processes can observe, the according process will do so. If an event occurs that both processes, $P$ and $Q$, are able to observe, then the choice which of them observes it will be made nondeterministically.

We have now seen some basic combinators of \textsc{CSP} and how to use them in order to create composed processes based on primitive processes and events. We can construct processes that run in parallel and make their execution dependant on observable events. The formalism of \textsc{CSP} allows reasoning about processes and transformations on them. \textsc{CSP} comes with many more operators and combinators than the ones we have introdcued, but as already mentioned we do not intend to give a complete description.

Unfortunately in \textsc{CSP} there exists communication between processes that is implicitly represented as events. Since we want to eliminate explicit communication between processes, \textsc{CSP} is unsuitable for our purposes.

\subsection{$\pi$ calculus}

\section{Programming languages}

\subsection{Java}

\subsection{Erlang}

\subsection{Haskell}