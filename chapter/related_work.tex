\chapter{Related Work}
We will give an overview on related work that has been done in this field. First, we briefly introduce two process calculi, i.e. formalisms that allow to describe the behaviour of processes. After that, we will discuss how these formal concepts can be used in programming.

\section{Process calculi}
Process calculi are formalisms that can be used to describe processes and their behaviour in a concurrent system on a high level. The description is done in a mathematical way, comparable to algebraic structures, and independently from an implementation \cite{}. Usually process calculi operate on abstract processes and provide a set of operators and combinators which can be used to compose processes. By introducing this kind of formalism, process calculi make it possible to reason about processes and perform (equivalence) transformations on them, e.g. to obtain a more optimised\footnote{Optimised according to a defined criterion.} representation \cite{}. In \cite{Hoare:2012:LPU:2368298.2368301}, an algebraic model, which can be used to derive different process calculi, has been introduced. The common, generalised model for various process calculi shows that these calculi are essentially equivalent and can be used to express the same thing.

\subsection{Calculus of Communicating Systems}
The Calculus of Communicating Systems, short \textsc{CCS}, is a process algebra introduced by Robin Milner in 1982 \cite{Milner:1982:CCS:539036}. \textsc{CCS} was one of the first process calculi in the history of computer science. It comprises a relatively small set of combinators which are used to describe process behaviour. We will give an overview over most of them and illustrate how to use them. Note that our introduction to \textsc{CCS} will not be complete and we only want to give a general idea.

In \textsc{CCS}, processes are composed of actions $\mathcal{A}$ and processes $\mathcal{P}$. In the following, let $a \in \mathcal{A}$ be actions and $P, Q, R \in \mathcal{P}$ be processes.

Processes in \textsc{CCS} are defined inductively. The empty process $\emptyset$ is the process that does nothing. Processes can be prefixed with an action to obtain a new process. $a.P$ describes a process that can execute action $a$ before it continues as process $P$. We can use the empty process $\emptyset$ together with the prefixing of actions \enquote{.} to build a process that consists of an arbitrary long but finite sequence of actions.

The composition of two processes can be made with the choice operator \enquote{+} and the parallel operator \enquote{|}. $P + Q$ describes a process that will proceed as either $P$ or $Q$. With $P \,|\, Q$ we can describe that processes $P$ and $Q$ exist and the same time and execute concurrently. Both for \enquote{+} and \enquote{|} the laws of associativity and commutativity hold as shown in the following equations:
\begin{eqnarray*}
  P + \left( Q + R \right) & = & \left( P + Q \right) + R \\
  P \,|\, \left( Q \,|\, R \right) & = & \left( P \,|\, Q \right) \,|\, R \\
  P + Q & = & Q + P \\
  P \,|\, Q & = & Q \,|\, P.
\end{eqnarray*}
Furthermore, \enquote{$|$} distributes over \enquote{$+$}:
\begin{eqnarray*}
  P \,|\, \left( Q + R \right) & = & \left( P \,|\, Q \right) + \left( P \,|\, R \right).
\end{eqnarray*}

\textsc{CCS} contains more than we have seen here, e.g. aliasing of processes and thereby introducing recursion. Sequential and parallel composition using the shown combinators as well as choice between processes is straight forward and intuitive.

\subsection{Communicating Sequential Processes}
Communicating Sequential Processes, or short \textsc{CSP}, was developed by Tony Hoare and published in 1985 \cite{Hoare:1985:CSP:3921}. It arose around the same time as \textsc{CCS} and belongs to the circle of the first process calculi. We will introduce a subset of \textsc{CSP} and show how to build processes using \textsc{CSP}, however we will not go too deep into detail and don't claim to provide a complete description.

In \textsc{CSP}, processes are composed of two types of primitives: sequential processes $\mathcal{P}$ and events $\mathcal{E}$. A process $P \in \mathcal{P}$ can observe an event $e \in \mathcal{E}$ and react to it. It cannot take influence on events or manipulate them as they are indivisible. In the following, let $P, Q \in \mathcal{P}$ be processes and $a,b \in \mathcal{E}$ be events.

The prefix combinator \enquote{$\to$} takes an event $a$ and a process $P$. $\left( a \to P \right)$ creates a new process that waits until it observes $a$ and then behaves like $P$. A process that repeatedly waits to observe $a$ and then behaves like $P$ can be described using recursion: $P = \left( a \to P \right)$.

With the choice operator \enquote{$|$} we can construct a process that allows two flows of control. The process $\left( a \to P \,|\, b \to Q \right)$ will wait until it either observes $a$ and then behave like $P$ or it will wait until it observes $b$ and then behave like $Q$. Note that the prefix operator binds stronger than the choice operator and that the choice operator is commutative.

The parallel operator \enquote{$||$} allows us to put processes together such that they run parallel. The process obtained by $\left( P \,||\, Q \right)$ will wait for an event that both $P$ and $Q$ can observe and then behave like $P$ and $Q$ concurrently\footnote{Note the difference between concurrency and nondeterminism.}. Let $P = \left( a \to P \,|\, b \to a \to P \right)$ and $Q = a \to Q$ then $\left( P \,||\, Q \right) = \left( a \to P \,||\, a \to Q \right)$, since $Q$ cannot observe $b$ and thus the second choice from $P$ has to be ommited.

In contrast to the parallel operator \enquote{$||$}, the interleaving operator \enquote{$|||$} can be used to put processes together to execute concurrently, independently from which events they are able to observe. The process $\left( P \,|||\, Q \right)$ behaves like $P$ and $Q$ at the same time. If an event occurs that either of the processes can observe, the according process will do so. If an event occurs that both processes, $P$ and $Q$, are able to observe, then the choice which of them observes it will be made nondeterministically.

We have now seen some basic combinators of \textsc{CSP} and how to use them in order to create composed processes based on primitive processes and events. We can construct processes that run in parallel and make their execution dependant on observable events. The formalism of \textsc{CSP} allows reasoning about processes and transformations on them. \textsc{CSP} comes with many more operators and combinators than the ones we have introdcued, but as already mentioned we do not intend to give a complete description.

%Unfortunately in \textsc{CSP} there exists communication between processes that is implicitly represented as events. Since we want to eliminate explicit communication between processes, \textsc{CSP} is unsuitable for our purposes.

\section{Application in programming}
Current programming languages usually have tools for parallel and concurrent programming included. These tools might be realised using a runtime system, a virtual machine or could be found in a library. Syntactically, sequential and parallel composition as well as the choice between processes will look differently in different languages, yet the underlying semantics are the same\footnote{Of course only the semantics concerning process composition. Not so the semantics regarding program evaluation.}. This is why we will not dive into the concrete syntax of a particular programming language, but rather describe how to apply the general idea.

Two processes can be combined sequentially by running one of the processes first, waiting for its termination and then running the other one. Parallel composition can be done by simply starting processes at the same time. A choice between processes can be made using the conventional choice operator from sequential programming. Descriptions made in, e.g. \textsc{CCS} can be resembled using this approach.

However, in either case it is neccessary to explicitly write the desired composition down. There is usually no direct way of composing processes and (re-)using them as first class values. This unfortunately results in lengthy, unmodular code. We would rather wish for a compact method, similar to the syntax of \textsc{CCS} and \textsc{CSP}, of performing process composition.