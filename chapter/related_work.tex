\chapter{Related Work}
We will give an overview on related work that has been done in this field. First, we briefly introduce two process calculi, i.e. formalisms that allow to describe the behaviour of processes. After that we will have a look at how these concepts are implemented in some current programming languages.

\section{Process calculi}
Process calculi are formalisms that can be used to describe processes and their behaviour in a concurrent system on a high level. The description is done in a mathematical way, comparable to algebraic structures, and independently from an implementation \cite{}. Usually process calculi operate on abstract processes and provide a set of operators and combinators which can be used to compose processes. By introducing this kind of formalism, process calculi make it possible to reason about processes and perform (equivalence) transformations on them, e.g. to obtain a more optimised\footnote{Optimised according to a defined criterion.} representation \cite{}.

\subsection{Communicating Sequential Processes}
Communicating Sequential Processes, or short CSP, was the first process algebra in the history of computer science. It has been developed by Tony Hoare and was published in 1985 \cite{Hoare:1985:CSP:3921}. We are going to introduce a subset of CSP and show how to build processes using CSP, however we will not go too deep into detail and don't claim to provide a complete description.

In CSP, processes are composed of two types of primitives: sequential processes $\mathcal{P}$ and events $\mathcal{E}$. A process $P \in \mathcal{P}$ can observe an event $e \in \mathcal{E}$ and react to it. It cannot take influence on events or manipulate them as they are indivisible. In the following, let $P, Q \in \mathcal{P}$ be processes and $a,b \in \mathcal{E}$ be events.

The prefix combinator \enquote{$\to$} takes an event $a$ and a process $P$. $\left( a \to P \right)$ creates a new process that waits until it observes $a$ and then behaves like $P$. A process that repeatedly waits to observe $a$ and then behaves like $P$ can be described using recursion: $P = \left( a \to P \right)$.

With the choice operator \enquote{$|$} we can construct a process that allows two flows of control. The process $\left( a \to P \,|\, b \to Q \right)$ will wait until it either observes $a$ and then behave like $P$ or it will wait until it observes $b$ and then behave like $Q$. Note that the prefix operator binds stronger than the choice operator.

\subsection{$\pi$ calculus}

\section{Programming languages}

\subsection{Java}

\subsection{Erlang}

\subsection{Haskell}