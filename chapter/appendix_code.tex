\chapter{Code}

\clearpage

\section{Implementation of the process interpreter in the Cloud Haskell Process monad}
\label{app:distributed_split_slice}
\begin{lstlisting}[language=Haskell,frame=tb,numbers=left,caption=Implementation of \texttt{runProcess} in the \textsf{Cloud Haskell} \texttt{Process} monad.]
runProcess master (Choice c acd p p1 p2) x =
  runProcess master (if p (acd x c) then p1 else p2) x

runProcess master (Sequence p1 p2) x =
  runProcess master p1 x >>= runProcess master p2

runProcess master (Parallel p1 p2 combinator) x = do
  runProcess master (Split (id &&& id) p1 p2 combinator) x

runProcess master (Multilel ps ib fold) x = do
  runProcess master (Slice repeat ps ib fold) x

runProcess master (Split split p1 p2 combinator) x = do
  let (xl, xr) = split x
  mvar <- liftIO newEmptyMVar
  _ <- spawnLocal $ runProcessHelper master p1 xl mvar
  r2 <- runProcess master p2 xr
  r1 <- liftIO $ takeMVar mvar
  runProcess master combinator (r1, r2)

runProcess master (Slice slice ps ib fold) x = do
  let pairs = ps `zip` slice x
  mvars <- forM pairs $ \_ -> liftIO newEmptyMVar
  mapM_ (\((proc, x'), mvar) -> spawnLocal $ runProcessHelper master proc x' mvar) (pairs `zip` mvars)
  ress  <- forM mvars $ \mvar -> liftIO . takeMVar $ mvar
  runProcess master fold (ib, ress)

runProcess master (Loop ib ic pred ba acc p) x =
  if pred (acc x ic) then do
    x' <- runProcess master p x
    runProcess master (Loop x' (acc x ic) pred ba acc p) (ba x')
  else
    return ib

runProcessHelper :: Master -> Process a b -> a -> MVar b -> CH.Process ()
runProcessHelper master p x mvar = do
  r <- runProcess master p x
  liftIO $ putMVar mvar r
\end{lstlisting}

\begin{landscape}
\section{Ant system processes}
\label{app:ant_system_processes}

\begin{lstlisting}[language=Haskell,frame=tb,numbers=left,caption=Type aliases and the implementation of ants as a \textsf{BasicProcess}.]
type Visited     = [Node]
type Unvisited   = [Node]
type AntSolution = (Path, Int)

ant :: Configuration -> BasicProcess AntSolution
ant Configuration {..} = do
  path <- runAnt graph pheromones [1] (nodes graph \\ [1])
  return (path, pathLength' graph path)
    where
      runAnt :: Graph Int -> Pheromones -> Visited -> Unvisited -> BasicProcess Path
      runAnt _ _ visited        [] = return visited
      runAnt g p visited unvisited = do
        let tau   = distance' p (last visited)
        let eta   = (1.0/) . fromIntegral . distance' g (last visited)
        let probs = [tau u**alpha * eta u**beta | u <- unvisited]
        rand <- liftIO $ randomRIO (0, sum probs)
        let next  = fst . head . dropWhile ((< rand) . snd) $ zip unvisited (scanl1 (+) probs)
        runAnt g p (visited ++ [next]) (unvisited \\ [next])
\end{lstlisting}


\begin{lstlisting}[language=Haskell,frame=tb,numbers=left,caption=Implementation of a combinator process for ant solutions as \textsf{BasicProcess}.,firstnumber=16]
combinePaths :: (Configuration, [AntSolution]) -> BasicProcess Configuration
combinePaths (conf@(Configuration {..}), ass) = return conf { pheromones = pheromones', path = path', pathLen = len' }
  where
    pheromones'   = depositPheromones ass pheromones
    (path', len') = minimumBy (compare `on` snd) ass
\end{lstlisting}

\end{landscape}