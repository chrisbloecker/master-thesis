\chapter{An algebraic model\index{Algebraic!model}}
\label{chp:algebraic_model}
In the previous chapter we have seen two examples of process calculi\index{Process!calculus} and how they work. Before we start to define our own calculus for parallel and distributed programming, we develop an abstract algebraic model, similar to the one presented in \cite{Hoare:2012:LPU:2368298.2368301} and use it to define the semantics\index{Semantics} of our calculus.

First, let us define what we mean by \textit{process}\index{Process} a process is (a piece of) a computer program. It can run concurrently with other processes. A process receives an input\index{Input} and produces an output\index{Output}. Essentially, a process can be seen as a function\index{Function} and just like that, it is pure and free of side-effects\index{Side-effect}, it does not have any other state\index{State} than the input it receives upon creation.

For now we are not interested in \textbf{what} a process does or \textbf{how} it does that. We treat processes as black boxes that receive an input, perform an action and eventually produce an output. Our point of interest is the composability of processes and the algebraic structure we can define on them.

\section{Syntax\index{Syntax}}
\label{chp:syntax}
Let $\mathcal{P}$ be the set of processes\index{Process} and let $P, Q, R \in \mathcal{P}$ be processes. Then syntactically correct processes can be formed by using the following construction rules:
%$\mathcal{P}$ represents the set of computable functions\index{Function} in form of processes and hence, is countable\footnote{For every computable function there is a Turing machine that computes it. There is a GÃ¶del numbering for Turing machines, thus the number of Turing machines and the number of computable functions is countable.}. 
\begin{itemize}
  \item $\choice{R}{P}{Q}$ \hspace*{2.3em} (Choice)\index{Syntax!Choice}
  \item $\parallel{R}{P}{Q}$ \hspace*{2.8em} (Parallel)\index{Syntax!Parallel}
  \item $\sequence{P}{Q}$ \hspace*{4.8em} (Sequence)\index{Syntax!Sequence}
  \item $\repetition{R}{P}$ \hspace*{4.4em} (Repetition)\index{Syntax!Repetition}
%  \item $P^*$ \hspace*{3.5em} (Repetition)\index{Operator!repetition}
%  \vspace*{-0.4em}
%  \item $\left( P \right)$
\end{itemize}

\nomenclature{$\mathcal{P}$}{Set of all processes}
\nomenclature{$P,Q,R$}{Processes}
\nomenclature{$\choiceop$}{Choice Operator}
\nomenclature{$\parallelop$}{Parallel Operator}
\nomenclature{$\sequenceop$}{Sequence Operator}
%\nomenclature{$\repetitionop$}{\textsc{Kleene} star for repetition}

%The syntax can also be expressed in form of a grammar $G = \left( N, T, R, P \right)$, where $N = \left\{ P \right\}$ is the set of non-terminals, $T = \mathcal{P}$ is the set of terminals, $R$ is the set of production rules and $P$ is the start symbol \cite{Hopcroft:2006:IAT:1196416} with % ToDo!
%\begin{eqnarray*}
%  R \colon \quad P & \to & P \vee P \\
%    & | & P \,|\, P \\
%    & | & P \circ P \\
%    & | & P^* \\
%    & | & \left( P \right) \\
%    & | & p \quad\quad\quad\quad \text{for every } p \in \mathcal{P}
%\end{eqnarray*}
%Note that $G$ is context-free-like since it involves a Dyck language \cite{} and a countable set of terminals.




% ==============================================================================
% static semantics
% ==============================================================================

\section{Static Semantics\index{Semantics!static}}
\label{chp:static_semantics}
In this chapter we define the static semantics of our algebraic model\index{Algebraic!model}. We define what a \textbf{basic}\index{Process!basic} and what a \textbf{composed}\index{Process!composed} process is and we equip processes with a type signature\index{Type!signature}. The \textbf{type signature} of a process determines whether the process can be used for composition with other processes, respective to a combinator.

As before, let $\mathcal{P}$ be the set of processes. A basic\index{Process!basic}, or atomic\index{Process!atomic}, process is a process that performs an atomic operation an is no further divisible insofar, that it does not involve any of the introduced process combinators. A composed\index{Process!composed} process is a process that is composed of other processes, using one or many process combinators.

Intuitively, we call values that we present to processes their \textbf{input} and values produced by processes their \textbf{output}.

%\begin{definition}[Operator precedence\index{Operator!precedence}]
%\label{def:operator_precedence}
%The operator precedence in our algebra is as follows: $\sequenceop$ binds strongest, the next weaker binding operator is $\parallelop$, followed by $\choiceop$ in the end. Parentheses, as described in the syntax, might be necessary to overcome precedence and express the desired composition.

%\hfill\qedsymbol
%\end{definition}

\begin{definition}[Types\index{Type}]
Let $\mathcal{T}$ be the set of types and $T_i$ a type for every $i$ with
\begin{equation*}
  \mathcal{T} = \bigcup_i \left\{ T_i \right\}
\end{equation*}
Furthermore, let lowercase letters, e.g. $a, b, c$ be type variables, i.e. placeholders for types.

\hfill\qedsymbol
\end{definition}

\begin{definition}[The type Boolean]
Let $T_{Boolean} \in \mathcal{T}$ be the type of truth values with
\begin{equation*}
  T_{Boolean} = \left\{False, True \right\}.
\end{equation*}

\hfill\qedsymbol
\end{definition}

\begin{definition}[Undefined values]
For every $T_i \in \mathcal{T}$, let $\bot_i \in T_i$ be the undefined value of type $T_i$ that is distinguishable from every other value of type $T_i$. Every type implicitly contains an undefined value, even if not explicitly mentioned. When talking about the undefined value $\bot$, we omit its type and only mention it explicitly when necessary.

\hfill\qedsymbol
\end{definition}

\nomenclature{$\mathcal{T}$}{Set of types}

% ------------------------------------------------------------------------------
% type signature
% ------------------------------------------------------------------------------
\begin{definition}[Type signature\index{Type!signature}]
\label{def:type_signature}
The type signature of a process states of which types the input and the output of a process are. Let $\rho \colon \mathcal{P} \to \mathcal{T} \times \mathcal{T}$ be the function that assigns a type signature to processes.

\hfill\qedsymbol
\end{definition}

% ------------------------------------------------------------------------------
% identity and error process
% ------------------------------------------------------------------------------

\begin{definition}[Identity\index{Process!Identity} and error\index{Process!Error} process]
Let $Id \in \mathcal{P}$ be the identity process, i.e. the process that outputs its input, and let $Err \in \mathcal{P}$ be the error process, i.e. the process that always returns the undefined value. To be precise, there is an identity process $Id_i$ with $\typesignature{Id_i}{T_i}{T_i}$ and an error process $Err_i$ with $\typesignature{Err_i}{T_i}{T_i})$ for every $T_i \in \mathcal{T}$. For simplicity, we refer to them as $Id$ and $Err$, but keep in mind that for every type, there is a specific identity and error process. Let their type signatures be $\typesignature{Id}{a}{a}$ and $\typesignature{Err}{a}{a}$, where $a$ is a type variable which resembles the fact that $Id$ and $Err$ represent a family of processes.

\hfill\qedsymbol
\end{definition}

\nomenclature{$Id$}{The identity process}
\nomenclature{$Err$}{The error process}
%\nomenclature{$\bot_i$}{The undefined value of type $i$}
\nomenclature{$\bot$}{The undefined value}
\nomenclature{$\rho$}{Function that assigns a type signature to a process}

% ------------------------------------------------------------------------------
% strictness
% ------------------------------------------------------------------------------
\begin{definition}[Strictness of processes\index{Strictness}]
\label{def:process_strictness}
Processes are strict in the undefined value. If the undefined value $\bot$ is presented to a process as its input, then the output of the process is the undefined value $\bot$. %Processes also give the undefined value as output whenever they receive an input value that lies outside their domain\index{Domain}.

\hfill\qedsymbol
\end{definition}

% ------------------------------------------------------------------------------
% processes as predicates
% ------------------------------------------------------------------------------
\begin{definition}[Processes as predicates]
Let $\mathcal{B} \subset \mathcal{P}$ be the set of processes with output type $T_{Boolean}$. A process $B \in \mathcal{B}$ with $\rho \left( B \right) = \left( a, T_{Boolean} \right)$ is a predicate.

\hfill\qedsymbol
\end{definition}


% ------------------------------------------------------------------------------
% choice
% ------------------------------------------------------------------------------
\begin{definition}[Static semantics of choice composition\index{Static Semantics!Choice}]
\label{def:static_choice}
Let $B \in \mathcal{B}$ and $P, Q \in \mathcal{P}$ be processes and let $a, b$ be type variables. Then the composition $\choice{B}{Q}{P}$ is valid iff
%Let $\choiceop \colon \mathcal{B} \times \mathcal{P} \times \mathcal{P} \to \mathcal{P}$ be the choice between two processes, guarded by a third process. In order to compose processes with $\choiceop$, their type signatures have to match. 
\begin{eqnarray*}
  \rho \left( B \right) & = & \left( a, T_{Boolean} \right) \\
  \rho \left( P \right) & = & \left( a, b \right) \\
  \rho \left( Q \right) & = & \left( a, b \right)
\end{eqnarray*}
and invalid otherwise. The type signature of the resulting process is $\typesignature{\choice{B}{P}{Q}}{a}{b}$.

\hfill\qedsymbol
\end{definition}


% ------------------------------------------------------------------------------
% parallel
% ------------------------------------------------------------------------------
\begin{definition}[Static semantics of parallel composition\index{Static Semantics!Parallel}]
Let $P, Q, R \in \mathcal{P}$ be processes and let $a, b, c, d$ be type variables. Then the composition $\parallel{R}{P}{Q}$ is valid iff
%Let $\parallelop \colon \mathcal{P} \times \mathcal{P} \times \mathcal{P} \to \mathcal{P}$ be the parallel composition of processes. 
\begin{eqnarray*}
  \rho \left( P \right) & = & \left( a, c \right) \\
  \rho \left( Q \right) & = & \left( a, d \right) \\
  \rho \left( R \right) & = & \left( \left( c, d \right), b \right)
\end{eqnarray*}
and invalid otherwise. The type signature of the resulting process is $\typesignature{\parallel{R}{P}{Q}}{a}{b}$.

\hfill\qedsymbol
\end{definition}


% ------------------------------------------------------------------------------
% sequence
% ------------------------------------------------------------------------------
\begin{definition}[Static semantics of sequential composition\index{Static Semantics!Sequence}]
\label{def:static_sequence}
Let $P, Q \in \mathcal{P}$ be processes and let $a, b, c$ be type variables. Then the composition $\sequence{P}{Q}$ is valid iff
%Let $\sequenceop \colon \mathcal{P} \times \mathcal{P} \to \mathcal{P}$ be the sequential composition of two processes. 
\begin{eqnarray*}
  \rho \left( P \right) & = & \left( a, c \right) \\
  \rho \left( Q \right) & = & \left( c, b \right)
\end{eqnarray*}
and invalid otherwise. The type signature of the resulting process is $\typesignature{\sequence{P}{Q}}{a}{b}$.

\hfill\qedsymbol
\end{definition}


% ------------------------------------------------------------------------------
% repetition
% ------------------------------------------------------------------------------
\begin{definition}[Static semantics of repetition\index{Static Semantics!Repetition}]
\label{def:static_repetition}
Let $B \in \mathcal{B}$ and $P \in \mathcal{P}$ be processes and let $a$ be a type variable. Then the composition $\repetition{B}{P}$ is valid iff
\begin{eqnarray*}
  \rho \left( B \right) & = & \left( a, T_{Boolean} \right) \\
  \rho \left( P \right) & = & \left( a, a \right) \\
\end{eqnarray*}
and invalid otherwise. The type signature of the resulting process is $\typesignature{\repetition{B}{P}}{a}{a}$.

\hfill\qedsymbol
\end{definition}



% ==============================================================================
% semantics
% ==============================================================================

\section{Semantics\index{Semantics}}
\label{chp:semantics}
In \chpref{chp:static_semantics} we have introduced static semantics and construction rules for processes. In this chapter, we give an inductive definition of process semantics. %In order to make this definition accurately, we need to introduce some terms first: \textit{argument}\index{Argument} of a process, \textit{result}\index{Result} of a process and \textit{running} a process.

%The argument $a$ of a process $P$ is the value that is presented to $P$ and that is transformed into a result value $r$ by $P$. The type of $a$ needs to match $P$'s input type, which is given by $\rho$. The relationship of $P$, $a$ and $r$ can be described using \textsc{Hoare} triples\index{Hoare!triple} from \textsc{Hoare}\index{Hoare!logic} logic \cite{}. In \textsc{Hoare} logic, $a$ is a precondition\index{Precondition}, $r$ is a postcondition\index{Postcondition} and $P$ is a command. The relationship between the three is given by $\left\{ a \right\} P \left\{ r \right\}$ and means that $P$ transform the program's state from a situation where $a$ holds to a situation where $r$ holds. To be precise, in \textsc{Hoare} logic both $a$ and $r$ are formulas in predicate logic. They are used to give certain assurances over the current program state. However, we can interpret $a$ and $r$ in a compatible way: Let $s$ be the state of the program, then the condition $a$ would mean that $s$ has to be exactly $a$.

%By running a process $P$, we mean presenting an argument $a$ to the process, applying its intrinsic function to $a$ and receiving a result value $r$, i.e. $\left\{ a \right\} P \left\{ r \right\}$. The goal of this chapter is to define the intrinsic function of a process which is exactly its semantics.

For the definition of process semantics, we introduce the polymorphic function 
\begin{equation*}
  sem \colon \mathcal{P} \times a \to b
\end{equation*}
$sem$ takes a process $P \in \mathcal{P}$ with $\typesignature{P}{a}{b}$, an input $x$ of type $a$ and defines the semantics of $P$ when applied to $x$, i.e. the function computed by $P$. We write $\sem{P}{x}$ for that. For a concrete value, $P$'s output can be obtained by function application.

Note that the expression $\sem{P}{x}$ is only legal if $x$ is of appropriate type to serve as input for $P$.


%\nomenclature{$a$}{Argument for a process}
%\nomenclature{$r$}{Result of a process}
\nomenclature{$sem$}{Function that gives the semantics of a process}

% ------------------------------------------------------------------------------
% atomic process
% ------------------------------------------------------------------------------
The semantics of an atomic\index{Process!atomic} process $P \in \mathcal{P}$ is directly given by the function it calculates. For an atomic process $P$, let $f_P$ be its intrinsic function. 
\begin{definition}[Semantics of atomic processes\index{Semantics!atomic process}]
  \label{def:sem_atomic}
  Let $P$ be an atomic process and $x$ be an input for $P$ of matching type, then the semantics $\sem{P}{x}$ is given by $P$'s intrinsic function $f_P$.
  \begin{equation}
    \label{eqn:sem_atomic}
    \sem{P}{x} = f_P \left( x \right)
  \end{equation}
  \hfill\qedsymbol
\end{definition}

\nomenclature{$f_P$}{Intrinsic function of a basic process $P$}


\begin{definition}[Semantics of the identity process\index{Semantics!identity process}\index{Process!identity}\index{Identity process}]
\label{def:sem_id}
Let $Id \in \mathcal{P}$ be the identity process, i.e. the process that always outputs its input, and $x$ be an input for $Id$.
\begin{equation}
  \label{eqn:sem_id}
  \sem{Id}{x} = x
\end{equation}
\hfill\qedsymbol
\end{definition}


\begin{example}[Semantics of an atomic process]
  \label{exp:sem_atomic}
  Let $\sigma \colon \mathbb{N} \to \mathbb{N}, x \mapsto x+1$ be the function that is intrinsic to the atomic process $S \in \mathcal{P}$. Then the semantics $\sem{S}{x}$ of $S$ applied to $x$ is given by its intrinsic function $\sigma$:
  \begin{equation}
    \sem{S}{x} = \sigma \left( x \right) = x \mapsto x+1
  \end{equation}
  Let $\delta \colon \mathbb{N} \to \mathbb{N}, x \mapsto 2x$ be the function that is intrinsic to the atomic process $D \in \mathcal{P}$. Then the semantics $\sem{D}{x}$ of $D$ applied to $x$ is given by its intrinsic function $\delta$:
  \begin{equation}
    \sem{D}{x} = \delta \left( x \right) = x \mapsto 2x
  \end{equation}
  \hfill\qedsymbol
\end{example}


%The error process $Err$ presents a special case here: as stated in \chpref{chp:static_semantics}, its output type is undefined. Hence, its result is always the undefined value, which is identified with the undefined type:
The semantics of the error process $Err$, no matter which input it receives, is always the undefined value $\bot$ of the respective type. 
\begin{definition}[Semantics of the error process\index{Semantics!error process}\index{Process!error}\index{Error process}]
\label{def:sem_err}
Let $Err \in \mathcal{P}$ be the error process, i.e. the process that always outputs the undefined value $\bot$.
  \begin{equation}
    \label{eqn:sem_error}
    \sem{Err}{x} = x \mapsto \bot
  \end{equation}
  \hfill\qedsymbol
\end{definition}

% ------------------------------------------------------------------------------
% composed processes
% ------------------------------------------------------------------------------
The semantics of composed\index{Process!composed} processes is determined by their structure and the involved sub-processes.

\begin{definition}[Sub-process\index{Sub-process}]
Let $P \in \mathcal{P}$ be a composed process. Then the processes $P$ is composed of are called the sub-processes of $P$.

\hfill\qedsymbol
\end{definition}

% ------------------------------------------------------------------------------
% choice
% ------------------------------------------------------------------------------
\begin{definition}[Semantics of choice composition\index{Semantics!Choice}]
\label{def:sem_choice}
Let $B \in \mathcal{B}$ and $P, Q \in \mathcal{P}$ be processes and let them be composed using choice composition, i.e. $\choice{B}{P}{Q}$. Let $x$ be an input of matching type for $B, Q, P$. Then, based on $\sem{B}{x}$, the resulting process behaves either like $P$ or $Q$. The semantics of $\choice{B}{P}{Q}$ is given by:
  \begin{equation}
    \label{eqn:sem_choice}
    \sem{\choice{B}{P}{Q}}{x} = \left\{ \begin{array}{ll}
      \sem{P}{x} & \text{if } \sem{B}{x} = True \\
      \sem{Q}{x} & \text{otherwise}
    \end{array}\right.
  \end{equation}
  
  \hfill\qedsymbol
\end{definition}

\begin{example}[Semantics of choice composition]
\label{exp:sem_chice}
Consider the definitions of $S$ and $D$ from \expref{exp:sem_atomic}. Furthermore, let $Even \in \mathcal{P}$ with $\typesignature{Even}{\mathbb{N}}{T_{Bool}}$ be the process that outputs $True$ if its input is an even number and $False$ otherwise. If we compose $S$ and $D$, guarded by $Even$, using the choice composition, the semantics of the resulting process is as follows:
  \begin{equation*}
    \sem{\choice{Even}{S}{D}}{x} = \left\{\begin{array}{ll}
      \sem{S}{x} & \text{if } x \text{ is even} \\
      \sem{D}{x} & \text{otherwise}
    \end{array}\right.
  \end{equation*}
  \hfill\qedsymbol
\end{example}


% ------------------------------------------------------------------------------
% parallel
% ------------------------------------------------------------------------------
\begin{definition}[Semantics of parallel composition\index{Semantics!Parallel}]
\label{def:sem_parallel}
Let $P, Q, R \in \mathcal{P}$ be processes and let them be composed using parallel composition, i.e. $\parallel{R}{P}{Q}$. Let $x$ be an input of matching type for $P, Q$. Then the semantics of the resulting process $\parallel{R}{P}{Q}$ is given by %Furthermore, let $\left( \left( T_a, T_r \right), \star \right)$ be a semigroup\footnote{A semigroup is an algebraic structure $(S, \cdot)$ where $S$ is a set and $\cdot\colon S \times S \to S$ is a binary operation on the elements of $S$ with associative property.}\index{Semigroup} with the commutative binary operation $\star \colon \left( T_a, T_r \right) \times \left( T_a, T_r \right) \to \left( T_a, T_r \right)$. The semantics of $Q \,\parallelop\, R$ is then given by %The semantics of the resulting process is given by running both $Q$ and $R$ on the same argument and combining the elements of their result sets using $\star$.
  \begin{equation}
    \label{eqn:sem_parallel}
    \sem{\parallel{R}{P}{Q}}{x} = \sem{R}{\left( \sem{P}{x}, \sem{Q}{x} \right)}
  \end{equation}
  \hfill\qedsymbol
\end{definition}


\begin{example}[Semantics of parallel composition]
\label{exp:sem_parallel}
Consider the definitions of $\sigma, \delta, S$ and $D$ from \expref{exp:sem_atomic}. Furthermore, let $sum \colon \mathbb{N} \times \mathbb{N} \to \mathbb{N}, \left( x, y \right) \mapsto x + y$ be the function that is intrinsic to the atomic process $Sum \in \mathcal{P}$. Then the semantics of the process created by parallel composition of $S$ and $D$, combined with $Sum$, using the parallel operator $\parallelop$ is: 
  \begin{eqnarray*}
    \sem{\parallel{Sum}{S}{D}}{x} & = & \sem{Sum}{\left( \sem{S}{x}, \sem{D}{x} \right)} \\
                                  & = & \sem{Sum}{\left( \sigma\left(x\right), \delta\left(x\right) \right)} \\
                                  & = & sum \left( \sigma\left(x\right), \delta\left(x\right) \right) \\
                                  & = & sum \left( x \mapsto x+1, x \mapsto 2x \right) \\
                                  & = & x \mapsto \left( x+1 \right) + \left( 2x \right) \\
                                  & = & x \mapsto 3x + 1
  \end{eqnarray*}
  \hfill\qedsymbol
\end{example}

%The reason why we need $\star$ to be commutative is the intuition one might have about parallel composition of processes. For two processes $Q, R \in \mathcal{P}$, it is a reasonable expectation that $Q \,\parallelop\, R$ and $R \,\parallelop\, Q$ behave exactly the same. Since in the definition of the semantics of parallel composition we employ $\star$ to combine the results of the parallel processes, the properties of $\star$ are transferred to the parallel composition operator $\parallelop$. Hence, if we want $\parallelop$ to have commutative properties, we have to require this from $\star$.

%Furthermore, for a semigroup\index{Semigroup} $\left(T_r, \star \right)$ that is employed to combine results of processes that are composed using the parallel operator $\parallel$, we require every $t_r \in T_r$, i.e. every concrete value of type $T_r$, to be idempotent\index{Idempotence} respective to $\star$:
%\begin{equation}
%  \label{eqn:idempotence}
%  \bigwedge_{t_r \in T_r} t_r \star t_r = t_r.
%\end{equation}

%\begin{theorem}
%If the property shown in \eqnref{eqn:idempotence} holds, we can guarantee that parallel composition of processes lives up to another reasonable intuition, i.e. parallel composition of a process with itself does not change its semantics. In other words, let $R \in \mathcal{P}$ and compose $R$ using $\parallel$ with itself, then $R \,\parallel\, R$ has the same semantics as $R$.
%\end{theorem}

%\begin{myproof}
%Let $R \in \mathcal{P}$ be a process with $\rho \left( R \right) = \left( T_a, T_r \right)$ and let $\left( T_r, \star \right)$ be a semigroup\index{Semigroup} that satisfies the property given in \eqnref{eqn:idempotence}. Then $sem \left\langle R \,\parallel\, R \right\rangle = sem \left\langle R \right\rangle$.
%  \begin{eqnarray*}
%    sem \left\langle R \,\parallel\, R \right\rangle & \overset{\defref{def:sem_parallel}}{=} & \left\{ r \star r \,|\, r \in sem \left\langle R \right\rangle \right\} \\
%    & \overset{\eqnref{eqn:idempotence}}{=} & \left\{ r \,|\, r \in sem \left\langle R \right\rangle \right\} \\
%    & = & sem \left\langle R \right\rangle 
%  \end{eqnarray*}
%  \hfill$\blacksquare$
%\end{myproof}



% ------------------------------------------------------------------------------
% sequence
% ------------------------------------------------------------------------------
\begin{definition}[Semantics of sequence composition\index{Semantics!Sequence}]
\label{def:sem_sequence}
Let $P, Q \in \mathcal{P}$ be processes and let them be composed using sequence composition, i.e. $\sequence{P}{Q}$. Let $x$ be an input of matching type for $P$. Then the semantics of the resulting process is given by:
  \begin{equation}
    \label{eqn:sem_sequence}
    \sem{\sequence{P}{Q}}{x} = \sem{Q}{\sem{P}{x}}
  \end{equation}
  \hfill\qedsymbol
\end{definition}

\begin{example}[Semantics of sequence composition]
\label{exp:sem_sequence}
Consider the definitions of $\sigma, \delta, S$ and $D$ from \expref{exp:sem_atomic} and use sequence composition to compose $D$ and $S$. Since $\sequenceop$ does not have commutative properties, $\sequence{S}{D}$ and $\sequence{D}{S}$ yield different results.
  \begin{eqnarray*}
    \sem{\sequence{S}{D}}{x} & = & \sem{D}{\sem{S}{x}} \\
                             & = & \sem{D}{\sigma \left( x \right)} \\
                             & = & \delta \left( \sigma \left( x \right) \right) \\
                             & = & \delta \left( x \mapsto x+1 \right) \\
                             & = & x \mapsto 2 \left( x+1 \right) \\
                             & = & x \mapsto 2x+2
  \end{eqnarray*}
  \begin{eqnarray*}
    \sem{\sequence{D}{S}}{x} & = & \sem{S}{\sem{D}{x}} \\
                             & = & \sem{S}{\delta \left( x \right)} \\
                             & = & \sigma \left( \delta \left( x \right) \right) \\
                             & = & \sigma \left( x \mapsto 2x \right) \\
                             & = & x \mapsto 2x + 1
  \end{eqnarray*}
  \hfill\qedsymbol
\end{example}



% ------------------------------------------------------------------------------
% repetition
% ------------------------------------------------------------------------------
\begin{definition}[Semantics of repetition composition\index{Semantics!Repetition}]
\label{def:sem_repetition}
Let $B \in \mathcal{B}$ and $P \in \mathcal{P}$ be processes and let them be composed using repetition composition, i.e. $\repetition{B}{P}$. Let $x$ be an input of matching type for $P$. Then the semantics of $\repetition{B}{P}$ is given by the recursive equation
  \begin{equation}
    \label{eqn_sem_repetition}
    \sem{\repetition{B}{P}}{x} = \sem{\choice{B}{\sequence{P}{\repetition{B}{P}}}{Id}}{x}
  \end{equation}

\hfill\qedsymbol
\end{definition}

\begin{example}[Semantics of repetition composition\index{Semantics!Repetition}]
\label{exp:sem_repetition}
Consider the definition of $\delta$ and $D$ from \expref{exp:sem_atomic} ... ToDo...
  \begin{eqnarray*}
    \sem{x}{y}
  \end{eqnarray*}
  \hfill\qedsymbol
\end{example}


% ------------------------------------------------------------------------------
% equivalence
% ------------------------------------------------------------------------------
\section{Semantic equivalence\index{Semantic equivalence}}
Based on the definition of process semantics $sem$, we can define a partial ordering $<$ on processes. The partial ordering can then be used to define semantic equivalence on processes.

\nomenclature{$\leq$}{Ordering on processes}


\begin{definition}[Partial ordering on processes\index{Process!Ordering}]
\label{def:process_ordering}
Let $P, Q \in \mathcal{P}$ be processes with $\rho \left( P \right) = \rho \left( Q \right)$. Then $P$ and $Q$ are in relation $P \leq Q$ iff $\sem{P}{x} \subseteq \sem{Q}{x}$.

Processes with different type signatures can not be ordered.

\hfill\qedsymbol
\end{definition}

\nomenclature{iff}{if and only if}


If two processes $P$ and $Q$ are in relation $\leq$, i.e. $P \leq Q$, then, given the same input, $P$ always produces the same output as $Q$. However, $Q$ might be defined on values where $P$ is undefined.

\begin{definition}[Equivalence of processes\index{Process!Equivalence}]
\label{def:process_equivalence}
Let $P, Q \in \mathcal{P}$ be processes. Then $P$ and $Q$ are equivalent iff both $P \leq Q$ and $Q \leq P$.
  \begin{equation}
    \label{eqn:equivalence}
    P \equiv Q \Leftrightarrow P \leq Q \wedge Q \leq P
  \end{equation}
  \hfill\qedsymbol
\end{definition}

\nomenclature{$\equiv$}{Process equivalence}

\begin{definition}[Process substitution\index{Process!substitution}]
\label{def:process_substitution}
Let $P, Q, R \in \mathcal{P}$ be processes and let $Q$ be a sub-process of $P$, i.e. $P$ contains $Q$ at some point in its structure. Then we can transform $P$ into a new process by replacing every occurrence of $Q$ with $R$ and write $P_{\left[ Q / R \right]}$ for this.

\hfill\qedsymbol
\end{definition}

\nomenclature{$P_{\left[ Q / R \right]}$}{Substitution of sub-process $Q$ by $R$ in $P$}


\begin{corollary}[Substitution with an equivalent process]
\label{crl:process_substitution}
Let $P, Q, R \in \mathcal{P}$ be processes and $Q \equiv R$. Then it follows from \defref{def:process_equivalence} and \defref{def:process_substitution} that $P_{\left[ Q / R \right]}$ is equivalent to $P$ iff $Q$ and $R$ are equivalent:
  \begin{equation}
    P \equiv P_{\left[ Q / R \right]} \Leftrightarrow Q \equiv R.
  \end{equation}
  \hfill\qedsymbol
\end{corollary}

The equivalence from \crlref{crl:process_substitution} can be used to perform transformations\index{Process!transformation} on processes and optimise\index{Optimisation} them according to some measurable property. E.g. assume that we have a process $P$ that involved $Q$ as a sub-process. Now if $Q$ has high time complexity and we have another process $R$ with low time complexity and $Q \equiv R$, then we might want to use $P_{\left[ Q / R \right]}$ in a productive system instead of $P$ in order to save run time.


% ------------------------------------------------------------------------------
% inverse process
% ------------------------------------------------------------------------------
\begin{definition}[Inverse process\index{Process!inverse}\index{Inverse process}]
\label{def:inverse_process}
Let $P \in \mathcal{P}$ be a process. Then an inverse process $\overline{P}$ for $P$ is a process that satisfies the following property:
  \begin{equation}
    \sequence{P}{\overline{P}} \equiv Id.
  \end{equation}
  \hfill\qedsymbol
\end{definition}

\nomenclature{$\overline{P}$}{Process that is inverse to $P$}


As a final remark, we want to point out that, for a process $P$ an inverse process as defined in \defref{def:inverse_process} does \textbf{not} exist in general since not every computable function is invertible\footnote{Take, e.g. the function $f \colon x \mapsto x^2$. Clearly, $f$ is not injective since $f \left( x \right) = f \left( -x \right)$ and therefore not invertible. However, there is an inverse relation $\overline{f_r} \colon x \mapsto \left\{ \overline{x} \,|\, f \left( \overline{x} \right) = x \right\}$ that maps a value $x$ to the set of values that, if $f$ is applied to them, will yield $x$.}.





% ==============================================================================
% laws
% ==============================================================================

\section{Laws\index{Laws}}
\label{chp:laws}
Based on the defined semantics of our process algebra, i.e. $sem$, we can find a set of laws that allow us to transform processes into an equivalent representation. This is a useful tool for the developer: the laws allow him to transform his processes into a different, equivalent representation.

In the following, let $B \in \mathcal{B}$ and $C, P, Q, R \in \mathcal{P}$ and assume that their types are suitable for the desired composition in the respective cases. Proofs for the stated laws can be found in \appref{chp:proofs}.

\subsection{Associativity\index{Associativity}\index{Laws!Associativity}}
The associative property holds for sequential composition.
\begin{eqnarray*}
  \sequence{P}{\sequence{Q}{R}} & \equiv & \sequence{\sequence{P}{Q}}{R}
\end{eqnarray*}

\subsection{Distributivity\index{Distributivity}\index{Laws!Distributivity}}
In our algebra, parallel composition and sequence composition distribute over choice composition. Furthermore, sequence composition distributes over parallel composition.
\begin{eqnarray*}
  \parallel{C}{P}{\choice{B}{Q}{R}} & \equiv & \choice{B}{\parallel{C}{P}{Q}}{\parallel{C}{P}{R}} \\
  \sequence{P}{\choice{B}{Q}{R}} & \equiv & \choice{B}{\sequence{P}{Q}}{\sequence{P}{R}} \\
  & & \\
  \sequence{P}{\parallel{C}{Q}{R}} & \equiv & \parallel{C}{\sequence{P}{Q}}{\sequence{P}{R}}
\end{eqnarray*}

\subsection{Idempotence\index{Idempotence}\index{Laws!Idempotence}}
Idempotence properties are dependant on both the operation at hand and a specific element. For every process $P$, choice composition with itself doesn't alter its meaning, regardless of the used predicate. Sequence composition shows idempotence properties for both the identity process $Id$ and the error process $Err$.
\begin{eqnarray*}
  \choice{B}{P}{P} & \equiv & P \\
  \sequence{Id}{Id} & \equiv & Id \\
  \sequence{Err}{Err} & \equiv & Err \\
\end{eqnarray*}

\subsection{Neutral elements\index{Neutral element}\index{Laws!Neutral Element}}
The identity process $Id$ is both a left and right neutral element for sequential composition.
\begin{eqnarray*}
  \sequence{Id}{P} & \equiv & P \\
  \sequence{P}{Id} & \equiv & P
\end{eqnarray*}