\chapter{An algebraic model}
In the previous chapter we have seen two examples of process calculi and how they work. Before we start to define our own calculus for distributed programming, we will develop a yet more abstract algebraic model, similar to the one presented in \cite{Hoare:2012:LPU:2368298.2368301}. We will use it to define the semantics of our calculus, which will implement the algebraic model.

First, let us define what we mean by \textit{process}: a process is (a piece of) a computer program. It can run concurrently with other processes. A process receives an input and produces an output. Essentially, a process can be seen as a function. % ToDo?

For now we are not interested in \textbf{what} a process does and \textbf{how} it does that. We will treat processes as black boxes that receive an input, perform an action and eventually produce an output. Our point of interest is the composability of processes and the algebraic structure we can define on them.

\section{Syntax}

Let $\mathcal{P}$ be the set of processes and let $P, Q \in \mathcal{P}$ be syntactically correct processes. Then
\begin{itemize}
  \item $P \vee Q$
  \item $P \circ Q$
  \item $P \,|\, Q$
  \item $P^*$
  \item $\left( P \right)$
\end{itemize}
are also syntactically correct processes.

\section{Semantics}
The operator precedence in our algebra is a follows: $*$ binds strongest, the next weaker operator is $\circ$, followed by $|$ and in the end $\vee$. Parentheses, as described in the syntax, might be necessary to express the desired composition.

Let $\mathcal{T}$ be the set of types and let $t_0, t_1, \ldots \in \mathcal{T}$ be types. Let $\rho \colon \mathcal{P} \to \mathcal{T} \times \mathcal{T}$ be a function that assigns a type signature to every process. Furthermore, let $Err \in \mathcal{P}$ the error process, i.e. the process that always fails.

Let $\vee \colon \mathcal{P} \times \mathcal{P} \to \mathcal{P}$ be the choice between two processes. $P \vee Q$ yields a process that either behaves like $P$ or $Q$. $\mathcal{P}$ is closed under $\vee$ since $\vee$ selects between $P$ and $Q$ and $P, Q \in \mathcal{P}$. In order to compose processes with $\vee$, their type signatures have to match. Let
\begin{eqnarray*}
  \rho \left( P \right) & = & \left( t_i, t_j \right) \\
  \rho \left( Q \right) & = & \left( t_k, t_l \right).
\end{eqnarray*}
Then $P \vee Q$ yields a valid process iff $t_i = t_k \wedge t_j = t_l$ and $Err$ otherwise.

Let $\circ \colon \mathcal{P} \times \mathcal{P} \to \mathcal{P}$ be the sequential composition of two processes. $Q \circ P$ means: first, execute $P$, then, execute $Q$. Clearly, $\mathcal{P}$ is closed under $\circ$ since the result is a process that lies in $\mathcal{P}$ by definition. Note that in order to compose processes with $\circ$, their type signatures have to match. Suppose we want to compose processes $P$ and $Q$ using $\circ$, i.e. $Q \circ P$ and
\begin{eqnarray*}
  \rho \left( P \right) & = & \left( t_0, t_i \right) \\
  \rho \left( Q \right) & = & \left( t_j, t_1 \right).
\end{eqnarray*}
Then the composition $Q \circ P$ yields a valid process iff $t_i = t_j$, and results in $Err$ otherwise. 

\section{Laws}
Let $Id \in \mathcal{P}$ be the identity process, i.e. the process that maps an input to itself.