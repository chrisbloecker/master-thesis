\chapter{An algebraic model\index{Algebraic!model}}
\label{chp:algebraic_model}
In the previous chapter we have seen two examples of process calculi\index{Process!calculus} and how they work. Before we start to define our own calculus for parallel and distributed programming, we develop an abstract algebraic model, similar to the one presented in \cite{Hoare:2012:LPU:2368298.2368301} and use it to define the semantics\index{Semantics} of our calculus.

First, let us define what we mean by \textit{process}\index{Process} a process is (a piece of) a computer program. It can run concurrently with other processes. A process receives an input\index{Input} and produces an output\index{Output}. Essentially, a process can be seen as a function\index{Function} and just like that, it is pure and free of side-effects\index{Side-effect}, it does not have any other state\index{State} than the input it receives upon creation.

For now we are not interested in \textbf{what} a process does or \textbf{how} it does that. We treat processes as black boxes that receive an input, perform an action and eventually produce an output. Our point of interest is the composability of processes and the algebraic structure we can define on them.

\section{Syntax\index{Syntax}}
\label{chp:syntax}
Let $\mathcal{P}$ be the set of processes\index{Process} and let $P, Q, R \in \mathcal{P}$ be processes. Then syntactically correct processes can be formed by using the following construction rules:
\begin{itemize}
  \item $\choice{R}{P}{Q}$ \hspace*{2.3em} (Choice)\index{Syntax!Choice}
  \item $\parallel{R}{P}{Q}$ \hspace*{2.8em} (Parallel)\index{Syntax!Parallel}
  \item $\sequence{P}{Q}$ \hspace*{4.8em} (Sequence)\index{Syntax!Sequence}
  \item $\repetition{R}{P}$ \hspace*{4.4em} (Repetition)\index{Syntax!Repetition}
\end{itemize}

\nomenclature{$\mathcal{P}$}{Set of all processes}
\nomenclature{$\mathcal{B}$}{Set of processes with output type $T_{Boolean}$}
\nomenclature{$B$}{Predicate}
\nomenclature{$C, P,Q,R$}{Processes}
\nomenclature{$\choiceop$}{Operator used in choice composition}
\nomenclature{$\parallelop$}{Operator used in parallel composition}
\nomenclature{$\sequenceop$}{Operator used in sequence composition}
\nomenclature{$\repetitionop$}{Operator used in repetition}
\nomenclature{$a,b,c,d,e$}{Type variables}
\nomenclature{$T_i$}{Data type $i$}


% ==============================================================================
% static semantics
% ==============================================================================

\section{Static Semantics\index{Semantics!static}}
\label{chp:static_semantics}
In this chapter we define the static semantics of our algebraic model\index{Algebraic!model}. We define what a \textbf{basic}\index{Process!basic} and what a \textbf{composed}\index{Process!composed} process is and we equip processes with a type signature\index{Type!signature}. The \textbf{type signature} of a process determines whether the process can be used for composition with other processes, respective to a combinator.

As before, let $\mathcal{P}$ be the set of processes. A basic\index{Process!basic}, or atomic\index{Process!atomic}, process is a process that performs an atomic operation an is no further divisible insofar, that it does not involve any of the introduced process combinators. A composed\index{Process!composed} process is a process that is composed of other processes, using one or many process combinators.

Intuitively, we call values that we present to processes their \textbf{input} and values produced by processes their \textbf{output}.

\begin{definition}[Types\index{Type}]
Let $\mathcal{T}$ be the set of types and $T_i$ a type for every $i$ with
\begin{equation*}
  \mathcal{T} = \bigcup_i \left\{ T_i \right\}
\end{equation*}
Furthermore, let lowercase letters, e.g. $a, b, c$ be type variables, i.e. placeholders for types.

\hfill\qedsymbol
\end{definition}

\begin{definition}[The type Boolean]
Let $T_{Boolean} \in \mathcal{T}$ be the type of truth values with
\begin{equation*}
  T_{Boolean} = \left\{False, True \right\}.
\end{equation*}

\hfill\qedsymbol
\end{definition}

\begin{definition}[Undefined values]
For every $T_i \in \mathcal{T}$, let $\bot_i \in T_i$ be the undefined value of type $T_i$ that is distinguishable from every other value of type $T_i$. Every type implicitly contains an undefined value, even if not explicitly mentioned. When talking about the undefined value $\bot$, we omit its type and only mention it explicitly when necessary.

\hfill\qedsymbol
\end{definition}

\nomenclature{$\mathcal{T}$}{Set of types}

% ------------------------------------------------------------------------------
% type signature
% ------------------------------------------------------------------------------
\begin{definition}[Type signature\index{Type!signature}]
\label{def:type_signature}
The type signature of a process states of which types the input and the output of a process are. Let $\rho \colon \mathcal{P} \to \mathcal{T} \times \mathcal{T}$ be the function that assigns a type signature to processes.

\hfill\qedsymbol
\end{definition}

% ------------------------------------------------------------------------------
% identity and error process
% ------------------------------------------------------------------------------

\begin{definition}[Identity\index{Process!Identity} and error\index{Process!Error} process]
Let $Id \in \mathcal{P}$ be the identity process, i.e. the process that outputs its input, and let $Err \in \mathcal{P}$ be the error process, i.e. the process that always returns the undefined value. To be precise, there is an identity process $Id_i$ with $\typesignature{Id_i}{T_i}{T_i}$ and an error process $Err_i$ with $\typesignature{Err_i}{T_i}{T_i})$ for every $T_i \in \mathcal{T}$. For simplicity, we refer to them as $Id$ and $Err$, but keep in mind that for every type, there is a specific identity and error process. Let their type signatures be $\typesignature{Id}{a}{a}$ and $\typesignature{Err}{a}{a}$, where $a$ is a type variable which resembles the fact that $Id$ and $Err$ represent a family of processes.

\hfill\qedsymbol
\end{definition}

\nomenclature{$Id$}{The identity process}
\nomenclature{$Err$}{The error process}
\nomenclature{$\bot$}{The undefined value}
\nomenclature{$\rho$}{Function that assigns a type signature to a process}

% ------------------------------------------------------------------------------
% processes as predicates
% ------------------------------------------------------------------------------
\begin{definition}[Processes as predicates]
Let $\mathcal{B} \subset \mathcal{P}$ be the set of processes with output type $T_{Boolean}$. A process $B \in \mathcal{B}$ with $\rho \left( B \right) = \left( a, T_{Boolean} \right)$ is a predicate.

\hfill\qedsymbol
\end{definition}


% ------------------------------------------------------------------------------
% choice
% ------------------------------------------------------------------------------
\begin{definition}[Static semantics of choice composition\index{Static Semantics!Choice}]
\label{def:static_choice}
Let $B \in \mathcal{B}$ and $P, Q \in \mathcal{P}$ be processes and let $a, b$ be type variables. Then the composition $\choice{B}{Q}{P}$ is valid iff
\begin{eqnarray*}
  \rho \left( B \right) & = & \left( a, T_{Boolean} \right) \\
  \rho \left( P \right) & = & \left( a, b \right) \\
  \rho \left( Q \right) & = & \left( a, b \right)
\end{eqnarray*}
and invalid otherwise. The type signature of the resulting process is $\typesignature{\choice{B}{P}{Q}}{a}{b}$.

\hfill\qedsymbol
\end{definition}


% ------------------------------------------------------------------------------
% parallel
% ------------------------------------------------------------------------------
\begin{definition}[Static semantics of parallel composition\index{Static Semantics!Parallel}]
Let $P, Q, R \in \mathcal{P}$ be processes and let $a, b, c, d$ be type variables. Then the composition $\parallel{R}{P}{Q}$ is valid iff
\begin{eqnarray*}
  \rho \left( P \right) & = & \left( a, c \right) \\
  \rho \left( Q \right) & = & \left( a, d \right) \\
  \rho \left( R \right) & = & \left( \left( c, d \right), b \right)
\end{eqnarray*}
and invalid otherwise. The type signature of the resulting process is $\typesignature{\parallel{R}{P}{Q}}{a}{b}$.

\hfill\qedsymbol
\end{definition}


% ------------------------------------------------------------------------------
% sequence
% ------------------------------------------------------------------------------
\begin{definition}[Static semantics of sequential composition\index{Static Semantics!Sequence}]
\label{def:static_sequence}
Let $P, Q \in \mathcal{P}$ be processes and let $a, b, c$ be type variables. Then the composition $\sequence{P}{Q}$ is valid iff
\begin{eqnarray*}
  \rho \left( P \right) & = & \left( a, c \right) \\
  \rho \left( Q \right) & = & \left( c, b \right)
\end{eqnarray*}
and invalid otherwise. The type signature of the resulting process is $\typesignature{\sequence{P}{Q}}{a}{b}$.

\hfill\qedsymbol
\end{definition}


% ------------------------------------------------------------------------------
% repetition
% ------------------------------------------------------------------------------
\begin{definition}[Static semantics of repetition\index{Static Semantics!Repetition}]
\label{def:static_repetition}
Let $B \in \mathcal{B}$ and $P \in \mathcal{P}$ be processes and let $a$ be a type variable. Then the composition $\repetition{B}{P}$ is valid iff
\begin{eqnarray*}
  \rho \left( B \right) & = & \left( a, T_{Boolean} \right) \\
  \rho \left( P \right) & = & \left( a, a \right) \\
\end{eqnarray*}
and invalid otherwise. The type signature of the resulting process is $\typesignature{\repetition{B}{P}}{a}{a}$.

\hfill\qedsymbol
\end{definition}



% ==============================================================================
% semantics
% ==============================================================================
\nomenclature{$sem$}{Function that gives the semantics of a process}
\nomenclature{$f_P$}{Intrinsic function of a basic process $P$}
\nomenclature{$\circ$}{Function composition}


\section{Semantics\index{Semantics}}
\label{chp:semantics}
In \chpref{chp:syntax} we have introduced syntactical rules for process construction and in \chpref{chp:static_semantics} we have introduced static semantics of processes. In this chapter, we define the semantics of processes. 

For the definition of process semantics, we introduce the polymorphic partial function 
\begin{equation*}
  sem \colon \mathcal{P} \to a \to b.
\end{equation*}
$sem$ takes a process $P \in \mathcal{P}$ and returns its meaning, i.e. the function computed by $P$. We write $\sem{P}$ for that. For a concrete value $x$, if of appropriate type to serve as input for $P$, we can apply the function returned by $sem$ to $x$ and receive the semantics of a process, applied to that value $x$. We write $\sem{P} \left( x \right)$ for that. The expression $\sem{P} \left( x \right)$ is legal iff $x$ is of appropriate type to serve as input for $P$.

\begin{definition}[Strictness of processes\index{Strictness}]
\label{def:sem_strictness}
Processes are strict in the undefined value. If the undefined value $\bot$ is presented to a process as its input, then the output of the process is the undefined value $\bot$. For every process $P \in \mathcal{P}$, the following equation holds:
\begin{equation*}
  \sem{P} \left( \bot \right) = \bot
\end{equation*}
\hfill\qedsymbol
\end{definition}

% ------------------------------------------------------------------------------
% atomic process
% ------------------------------------------------------------------------------
For every atomic process, there is a function that is intrinsic to that particular process: for an atomic process $P \in \mathcal{P}$, let its intrinsic function be called $f_P$. Composed processes do not involve an atomic function and the notation $f_P$ does not make sense if $P$ is not an atomic process. The semantics of an atomic\index{Process!atomic} process $P \in \mathcal{P}$ is directly given by its intrinsic function.
\begin{definition}[Semantics of atomic processes\index{Semantics!atomic process}]
  \label{def:sem_atomic}
  Let $P$ be an atomic process, then the semantics $\sem{P}$ is given by $P$'s intrinsic function $f_P$.
  \begin{equation*}
    \label{eqn:sem_atomic}
    \sem{P} = f_P
  \end{equation*}
  \hfill\qedsymbol
\end{definition}

% ------------------------------------------------------------------------------
% id
% ------------------------------------------------------------------------------
\begin{definition}[Semantics of the identity process\index{Semantics!identity process}\index{Process!identity}\index{Identity process}]
\label{def:sem_id}
Let $Id \in \mathcal{P}$ be the identity process, i.e. the process that always outputs its input, and $x$ be an input for $Id$.
\begin{equation*}
  \label{eqn:sem_id}
  \sem{Id} = x \mapsto x
\end{equation*}
\hfill\qedsymbol
\end{definition}


\begin{example}[Semantics of an atomic process]
  \label{exp:sem_atomic}
  Let $\sigma \colon \mathbb{N} \to \mathbb{N}, x \mapsto x+1$ be the function that is intrinsic to the atomic process $S \in \mathcal{P}$. Then the semantics $\sem{S}$ of $S$ is given by $\sigma$:
  \begin{equation*}
    \sem{S} = \sigma = x \mapsto x+1
  \end{equation*}
  Let $\delta \colon \mathbb{N} \to \mathbb{N}, x \mapsto 2x$ be the function that is intrinsic to the atomic process $D \in \mathcal{P}$. Then the semantics $\sem{D}$ of $D$ is given by $\delta$:
  \begin{equation*}
    \sem{D} = \delta = x \mapsto 2x
  \end{equation*}
\end{example}


The semantics of the error process $Err$, no matter which input it receives, is always the undefined value $\bot$ of the respective type. 
\begin{definition}[Semantics of the error process\index{Semantics!error process}\index{Process!error}\index{Error process}]
\label{def:sem_err}
Let $Err \in \mathcal{P}$ be the error process, i.e. the process that always outputs the undefined value $\bot$.
  \begin{equation*}
    \label{eqn:sem_error}
    \sem{Err} = x \mapsto \bot
  \end{equation*}
  \hfill\qedsymbol
\end{definition}

% ------------------------------------------------------------------------------
% composed processes
% ------------------------------------------------------------------------------
The semantics of composed\index{Process!composed} processes is determined by their structure and the involved sub-processes. The statement made in \defref{def:sem_strictness} remains true for composed processes: when the undefined value $\bot$ is presented as input, every process must output the undefined value. By convention, this does not need to be modelled explicitly for every process.

\begin{definition}[Sub-process\index{Sub-process}]
Let $P \in \mathcal{P}$ be a composed process. Then the processes $P$ is composed of are called the sub-processes of $P$.

\hfill\qedsymbol
\end{definition}

% ------------------------------------------------------------------------------
% choice
% ------------------------------------------------------------------------------
\begin{definition}[Shorthand notion for predicate processes]
Let $B \in \mathcal{B}$ be a predicate process. Then $B \left( x \right)$ is a shorthand notion for $\sem{B} \left( x \right) = True$ and $\overline{B \left( x \right)}$ is a shorthand notion for $\sem{B} \left( x \right) = False$.

\hfill\qedsymbol
\end{definition}

The semantics of a process with the structure of choice composition is that of one of its sub-processes. A predicate is employed to inspect the input and decide which of the sub-processes determines the semantics.
\begin{definition}[Semantics of choice composition\index{Semantics!Choice}]
\label{def:sem_choice}
Let $B \in \mathcal{B}$ and $P, Q \in \mathcal{P}$ be processes and let them be composed using choice composition, i.e. $\choice{B}{P}{Q}$. Let $x$ be an input of matching type for $B, Q, P$. Then, based on $\sem{B}$, the resulting process behaves either like $P$ or $Q$. The semantics of $\choice{B}{P}{Q}$ is given by:
  \begin{equation*}
    \label{eqn:sem_choice}
    \sem{\choice{B}{P}{Q}} = x \mapsto \left\{ \begin{array}{ll}
      \sem{P}\left(x\right) & \text{if } B \left( x \right) \\
      \sem{Q}\left(x\right) & \text{if } \overline{B \left( x \right)} \\
      \bot & \text{otherwise}
    \end{array}\right.
  \end{equation*}
  
  \hfill\qedsymbol
\end{definition}

\begin{example}[Semantics of choice composition]
\label{exp:sem_chice}
Consider the definitions of $S$ and $D$ from \expref{exp:sem_atomic}. Furthermore, let $Even \in \mathcal{P}$ with $\typesignature{Even}{\mathbb{N}}{T_{Bool}}$ be the process that outputs $True$ if its input is an even number and $False$ otherwise. If we compose $S$ and $D$, guarded by $Even$, using the choice composition, the semantics of the resulting process is as follows:
  \begin{equation*}
    \sem{\choice{Even}{S}{D}} = x \mapsto \left\{\begin{array}{ll}
      \sem{S}\left(x\right) & \text{if } x \text{ is even} \\
      \sem{D}\left(x\right() & \text{if } x \text{ is odd} \\
      \bot & \text{otherwise}
    \end{array}\right.
  \end{equation*}
\end{example}


% ------------------------------------------------------------------------------
% parallel
% ------------------------------------------------------------------------------
The semantics of a process with the structure of parallel composition is given by the semantics of its sub-processes, combined by a combinator process.
\begin{definition}[Semantics of parallel composition\index{Semantics!Parallel}]
\label{def:sem_parallel}
Let $P, Q, R \in \mathcal{P}$ be processes and let them be composed using parallel composition, i.e. $\parallel{R}{P}{Q}$. Then the semantics of the resulting process $\parallel{R}{P}{Q}$ is given by
  \begin{equation*}
    \label{eqn:sem_parallel}
    \sem{\parallel{R}{P}{Q}} = x \mapsto \sem{R} \left( \sem{P} \left( x \right), \sem{Q} \left( x \right) \right)
  \end{equation*}
  \hfill\qedsymbol
\end{definition}


\begin{example}[Semantics of parallel composition]
\label{exp:sem_parallel}
Consider the definitions of $\sigma, \delta, S$ and $D$ from \expref{exp:sem_atomic}. Furthermore, let $sum \colon \mathbb{N} \times \mathbb{N} \to \mathbb{N}, \left( x, y \right) \mapsto x + y$ be the function that is intrinsic to the atomic process $Sum \in \mathcal{P}$. Then the semantics of the process created by parallel composition of $S$ and $D$, combined with $Sum$, is: 
  \begin{eqnarray*}
    \sem{\parallel{Sum}{S}{D}} & = & x \mapsto \sem{Sum}{\left( \sem{S} \left( x \right), \sem{D} \left( x \right) \right)} \\
                               & = & x \mapsto \sem{Sum}{\left( \sigma\left(x\right), \delta\left(x\right) \right)} \\
                               & = & x \mapsto sum \left( \sigma\left(x\right), \delta\left(x\right) \right) \\
                               & = & x \mapsto sum \left( x+1, 2x \right) \\
                               & = & x \mapsto \left( x+1 \right) + \left( 2x \right) \\
                               & = & x \mapsto 3x + 1
  \end{eqnarray*}
\end{example}


% ------------------------------------------------------------------------------
% sequence
% ------------------------------------------------------------------------------
The semantics of a process with the structure of sequence composition is given by applying the semantics, i.e. functions, of its sub-processes sequentially. This can be achieved using function composition.
\begin{definition}[Semantics of sequence composition\index{Semantics!Sequence}]
\label{def:sem_sequence}
Let $P, Q \in \mathcal{P}$ be processes and let them be composed using sequence composition, i.e. $\sequence{P}{Q}$. Then the semantics of the resulting process is given by function composition:
  \begin{equation*}
    \label{eqn:sem_sequence}
    \sem{\sequence{P}{Q}} = \sem{Q} \circ \sem{P} = x \mapsto \sem{Q} \left( \sem{P} \left( x \right) \right)
  \end{equation*}
  \hfill\qedsymbol
\end{definition}


\begin{example}[Semantics of sequence composition]
\label{exp:sem_sequence}
Consider the definitions of $\sigma, \delta, S$ and $D$ from \expref{exp:sem_atomic} and use sequence composition to compose $D$ and $S$. Since $\sequenceop$ does not have commutative properties, $\sequence{S}{D}$ and $\sequence{D}{S}$ yield different results.
  \begin{eqnarray*}
    \sem{\sequence{S}{D}} & = & \sem{D} \circ \sem{S} \\
                          & = & \delta \circ \sigma \\
                          & = & x \mapsto \delta \left( \sigma \left( x \right) \right) \\
                          & = & x \mapsto 2 \left( x+1 \right) \\
                          & = & x \mapsto 2x+2
  \end{eqnarray*}
  \begin{eqnarray*}
    \sem{\sequence{D}{S}} & = & \sem{S} \circ \sem{D} \\
                          & = & \sigma \circ \delta \\
                          & = & x \mapsto \sigma \left( \delta \left( x \right) \right) \\
                          & = & x \mapsto 2x + 1
  \end{eqnarray*}
\end{example}


% ------------------------------------------------------------------------------
% repetition
% ------------------------------------------------------------------------------
The semantics of a process with the structure of repetition composition is either that of the identity process $Id$ or the sequential composition of another process and the repetition process itself, depending on a property of its input. A predicate is employed to check the input for a property and determine the semantics of the repetition process.
\begin{definition}[Semantics of repetition composition\index{Semantics!Repetition}]
\label{def:sem_repetition}
Let $B \in \mathcal{B}$ and $P \in \mathcal{P}$ be processes and let them be composed using repetition composition, i.e. $\repetition{B}{P}$. Then the semantics of $\repetition{B}{P}$ is given by the recursive equation
  \begin{equation*}
    \label{eqn_sem_repetition}
    \sem{\repetition{B}{P}} = \sem{\choice{B}{\sequence{P}{\repetition{B}{P}}}{Id}}
  \end{equation*}
  \hfill\qedsymbol
\end{definition}

\begin{example}[Semantics of repetition composition\index{Semantics!Repetition}]
\label{exp:sem_repetition}
Consider the definition of $\delta$ and $D$ from \expref{exp:sem_atomic} and let $B \in \mathcal{B}$ be a predicate that returns $True$ if its input is smaller than 1024 and $False$ if its input is equal to 1024 or bigger.
  \begin{eqnarray*}
    \sem{\repetition{B}{D}} & = & \sem{\choice{B}{\sequence{D}{\repetition{B}{D}}}{Id}} \\
                            & = & x \mapsto \left\{ \begin{array}{ll} 
                                                      \sem{\sequence{D}{\repetition{B}{D}}} \left( x \right) & \text{if } x < 1024 \\
                                                      \sem{Id} \left( x \right)                              & \text{if } x \geq 1024 
                                                    \end{array}
                                            \right. \\
                            & = & \ldots
  \end{eqnarray*}
$\repetition{B}{D}$ yields a process that takes its input, doubles it and passes it on recursively to itself as long as its input is smaller than 1024. If its input is bigger than 1024, it outputs its input.
\end{example}


% ------------------------------------------------------------------------------
% equivalence
% ------------------------------------------------------------------------------
\clearpage
\section{Semantic equivalence and substitution\index{Semantic equivalence}\index{Substitution}}
\label{chp:semantic_equivalence}
Based on the definition of process semantics from \chpref{chp:semantics}, we have a tool at hand to reason about processes and perform transformations on them.

\begin{definition}[Equivalence of processes\index{Process!Equivalence}]
\label{def:process_equivalence}
Let $P, Q \in \mathcal{P}$ be processes. Then $P$ and $Q$ are equivalent iff their semantics are the same. We write $P \equiv Q$ to indicate equivalence of $P$ and $Q$.
  \begin{equation*}
    \label{eqn:equivalence}
    P \equiv Q \Leftrightarrow \sem{P} = \sem{Q}
  \end{equation*}
  \hfill\qedsymbol
\end{definition}

\nomenclature{$\equiv$}{Process equivalence}

\begin{definition}[Process substitution\index{Process!substitution}]
\label{def:process_substitution}
Let $P, Q, R \in \mathcal{P}$ be processes and let $Q$ be a sub-process of $P$. Then we can transform $P$ into a new process by replacing one or more occurrence of $Q$ in $P$ with $R$ and write $P_{\left[ Q / R \right]}$ for this. The notion $P_{\left[ Q / R \right]}$ is only legal if $Q$ occurs in $P$ \textbf{at least} once.

\hfill\qedsymbol
\end{definition}

\nomenclature{$P_{\left[ Q / R \right]}$}{Substitution of sub-process $Q$ by $R$ in $P$}


\begin{theorem}[Substitution with an equivalent process leaves semantics unchanged]
\label{thm:process_substitution}
Let $P, Q, R \in \mathcal{P}$ be processes with $Q$ being a sub-process of $P$. Then, substituting one or more occurrences of $Q$ in $P$ with $R$ leaves $\sem{P}$ unchanged iff $Q \equiv R$.
  \begin{equation*}
    P \equiv P_{\left[ Q / R \right]} \Leftrightarrow Q \equiv R
  \end{equation*}
  \hfill\qedsymbol
\end{theorem}


The property stated in \thmref{thm:process_substitution} allows us to transforms processes into a different representation without altering their semantics and optimising them according to some measurable property. E.g. one might want to find more \enquote{simple} representation of a process or reduce its complexity by replacing sub-processes. A proof of \thmref{thm:process_substitution} can be found in \appref{chp:proofs}.

% ------------------------------------------------------------------------------
% inverse process
% ------------------------------------------------------------------------------
\begin{definition}[Inverse process\index{Process!inverse}\index{Inverse process}]
\label{def:inverse_process}
Let $P \in \mathcal{P}$ be a process. Then an inverse process $\overline{P}$ for $P$ is a process that satisfies the following property:
  \begin{equation*}
    \sequence{P}{\overline{P}} \equiv Id.
  \end{equation*}
  \hfill\qedsymbol
\end{definition}

\nomenclature{$\overline{P}$}{Process that is inverse to $P$}


As a final remark, we point out that, for a process $P$, an inverse process as defined in \defref{def:inverse_process} does \textbf{not} exist in general since not every computable function is invertible\footnote{Take, e.g. the function $f \colon x \mapsto x^2$. Clearly, $f$ is not injective since $f \left( x \right) = f \left( -x \right)$ and therefore not invertible. However, there is an inverse relation $\overline{f_r} \colon x \mapsto \left\{ \overline{x} \,|\, f \left( \overline{x} \right) = x \right\}$ that maps a value $x$ to the set of values that, if $f$ is applied to them, will yield $x$.}.



% ==============================================================================
% laws
% ==============================================================================
\clearpage
\section{Laws\index{Laws}}
\label{chp:laws}
In \chpref{chp:semantic_equivalence}, \defref{def:process_equivalence}, we have defined under which circumstances two processes are equivalent. This definition, together with the definitions for process semantics given in \chpref{chp:semantics}, allows us to find a set of laws regarding process equivalence in our model.

In the following, let $B \in \mathcal{B}$ and $C, P, Q, R \in \mathcal{P}$ be processes with suitable type signatures for composition in the respective cases. Proofs for the stated laws can be found in \appref{chp:proofs}.

\subsection{Associativity\index{Associativity}\index{Laws!Associativity}}
The associative property holds for sequence composition.
\begin{eqnarray*}
  \sequence{P}{\sequence{Q}{R}} & \equiv & \sequence{\sequence{P}{Q}}{R}
\end{eqnarray*}

\subsection{Distributivity\index{Distributivity}\index{Laws!Distributivity}}
Parallel and sequence composition distribute over choice composition. Also, sequence composition distributes over parallel composition.
\begin{eqnarray*}
  \parallel{C}{P}{\choice{B}{Q}{R}} & \equiv & \choice{B}{\parallel{C}{P}{Q}}{\parallel{C}{P}{R}} \\
  \sequence{P}{\choice{B}{Q}{R}} & \equiv & \choice{B}{\sequence{P}{Q}}{\sequence{P}{R}} \\
  \sequence{P}{\parallel{C}{Q}{R}} & \equiv & \parallel{C}{\sequence{P}{Q}}{\sequence{P}{R}}
\end{eqnarray*}

\subsection{Neutral elements\index{Neutral element}\index{Laws!Neutral Element}}
The identity process $Id$ is both a left and right neutral element for sequential composition.
\vspace*{-1em}
\begin{eqnarray*}
  \sequence{Id}{P} & \equiv & P \\
  \sequence{P}{Id} & \equiv & P
\end{eqnarray*}

\subsection{Idempotence\index{Idempotence}\index{Laws!Idempotence}}
Regardless of the used predicate, every process is idempotent regarding choice composition. The identity process $Id$ is idempotent regarding sequence composition since it is both a left and right neutral element of choice composition. The error process $Err$ is idempotent regarding sequence composition due to process' strictness in the undefined value. Furthermore, both $Id$ and $Err$ are idempotent respective to repetition composition, regardless of the used predicate.
\begin{eqnarray*}
  \choice{B}{P}{P} & \equiv & P \\
  \sequence{Id}{Id} & \equiv & Id \\
  \sequence{Err}{Err} & \equiv & Err \\
  \repetition{B}{Id} & \equiv & Id \\
  \repetition{B}{Err} & \equiv & Err
\end{eqnarray*}